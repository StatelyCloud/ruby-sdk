# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: db/list.proto
# typed: strict

class Stately::Db::BeginListRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      store_id: T.nilable(Integer),
      key_path_prefix: T.nilable(String),
      limit: T.nilable(Integer),
      allow_stale: T.nilable(T::Boolean),
      sort_property: T.nilable(T.any(Symbol, String, Integer)),
      sort_direction: T.nilable(T.any(Symbol, String, Integer)),
      schema_version_id: T.nilable(Integer),
      schema_id: T.nilable(Integer),
      filter_conditions: T.nilable(T::Array[T.nilable(Stately::Db::FilterCondition)]),
      key_conditions: T.nilable(T::Array[T.nilable(Stately::Db::KeyCondition)])
    ).void
  end
  def initialize(
    store_id: 0,
    key_path_prefix: "",
    limit: 0,
    allow_stale: false,
    sort_property: :SORTABLE_PROPERTY_KEY_PATH,
    sort_direction: :SORT_ASCENDING,
    schema_version_id: 0,
    schema_id: 0,
    filter_conditions: [],
    key_conditions: []
  )
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { returns(Integer) }
  def store_id
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { params(value: Integer).void }
  def store_id=(value)
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { void }
  def clear_store_id
  end

  # key_path_prefix is the a prefix that limits what items we will return. This
# must contain at least a root segment. See Item#key_path for more details.
  sig { returns(String) }
  def key_path_prefix
  end

  # key_path_prefix is the a prefix that limits what items we will return. This
# must contain at least a root segment. See Item#key_path for more details.
  sig { params(value: String).void }
  def key_path_prefix=(value)
  end

  # key_path_prefix is the a prefix that limits what items we will return. This
# must contain at least a root segment. See Item#key_path for more details.
  sig { void }
  def clear_key_path_prefix
  end

  # limit is the maximum number of items to return. If this is not specified or
# set to 0, it will default to unlimited. Fewer items than the limit may be
# returned even if there are more items to get - make sure to check
# token.can_continue.
  sig { returns(Integer) }
  def limit
  end

  # limit is the maximum number of items to return. If this is not specified or
# set to 0, it will default to unlimited. Fewer items than the limit may be
# returned even if there are more items to get - make sure to check
# token.can_continue.
  sig { params(value: Integer).void }
  def limit=(value)
  end

  # limit is the maximum number of items to return. If this is not specified or
# set to 0, it will default to unlimited. Fewer items than the limit may be
# returned even if there are more items to get - make sure to check
# token.can_continue.
  sig { void }
  def clear_limit
  end

  # allow_stale indicates that you're okay with getting slightly stale items -
# that is, if you had just changed an item and then call a List operation,
# you might get the old version of the item. This can result in improved
# performance, availability, and cost.
  sig { returns(T::Boolean) }
  def allow_stale
  end

  # allow_stale indicates that you're okay with getting slightly stale items -
# that is, if you had just changed an item and then call a List operation,
# you might get the old version of the item. This can result in improved
# performance, availability, and cost.
  sig { params(value: T::Boolean).void }
  def allow_stale=(value)
  end

  # allow_stale indicates that you're okay with getting slightly stale items -
# that is, if you had just changed an item and then call a List operation,
# you might get the old version of the item. This can result in improved
# performance, availability, and cost.
  sig { void }
  def clear_allow_stale
  end

  # sort_property is the property of the item to sort the results by. If this
# is not set, we will sort by key path.
  sig { returns(T.any(Symbol, Integer)) }
  def sort_property
  end

  # sort_property is the property of the item to sort the results by. If this
# is not set, we will sort by key path.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def sort_property=(value)
  end

  # sort_property is the property of the item to sort the results by. If this
# is not set, we will sort by key path.
  sig { void }
  def clear_sort_property
  end

  # sort_direction is the direction to sort the results in. If this is not set,
# we will sort in ascending order.
  sig { returns(T.any(Symbol, Integer)) }
  def sort_direction
  end

  # sort_direction is the direction to sort the results in. If this is not set,
# we will sort in ascending order.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def sort_direction=(value)
  end

  # sort_direction is the direction to sort the results in. If this is not set,
# we will sort in ascending order.
  sig { void }
  def clear_sort_direction
  end

  # schema_version_id is the version of the store's schema to use to interpret
# items. If there is no version with this ID, the operation will error with
# SchemaVersionNotFound error. You should not have to set this manually as
# your generated SDK should know its schema version and wire this in for you.
  sig { returns(Integer) }
  def schema_version_id
  end

  # schema_version_id is the version of the store's schema to use to interpret
# items. If there is no version with this ID, the operation will error with
# SchemaVersionNotFound error. You should not have to set this manually as
# your generated SDK should know its schema version and wire this in for you.
  sig { params(value: Integer).void }
  def schema_version_id=(value)
  end

  # schema_version_id is the version of the store's schema to use to interpret
# items. If there is no version with this ID, the operation will error with
# SchemaVersionNotFound error. You should not have to set this manually as
# your generated SDK should know its schema version and wire this in for you.
  sig { void }
  def clear_schema_version_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { returns(Integer) }
  def schema_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { params(value: Integer).void }
  def schema_id=(value)
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { void }
  def clear_schema_id
  end

  # filter_conditions are a set of conditions to filter the list result by.
# If no conditions are provided, all items in the store will be returned.
# Filter conditions are combined with OR.
  sig { returns(T::Array[T.nilable(Stately::Db::FilterCondition)]) }
  def filter_conditions
  end

  # filter_conditions are a set of conditions to filter the list result by.
# If no conditions are provided, all items in the store will be returned.
# Filter conditions are combined with OR.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def filter_conditions=(value)
  end

  # filter_conditions are a set of conditions to filter the list result by.
# If no conditions are provided, all items in the store will be returned.
# Filter conditions are combined with OR.
  sig { void }
  def clear_filter_conditions
  end

  # key_conditions are a set of conditions to apply to the list operation.
# Wherever possible, Stately will apply these key conditions at the DB layer
# to optimize the list operation cost.
#
# A maximum of two key conditions are allowed: one with a GREATER_THAN (or equal to)
# operator and one with a LESS_THAN (or equal to) operator. Together these amount to
# a "between" condition on the key path.
#
# If these conditions are provided they must share the same prefix as the
# key_path_prefix. For example, the following is valid:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/namespace-44"
#       operator: GREATER_THAN_OR_EQUAL
#     - key_path: "/group-:groupID/namespace-100"
#       operator: LESS_THAN_OR_EQUAL
#
# A key_path_prefix of "/group-:groupID" would also be valid above, as the prefix is shared
# with the key conditions.
#
# The following is NOT valid because the key_path_prefix does not
# share the same prefix as the key conditions:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/beatles-1984"
#       operator: GREATER_THAN_OR_EQUAL
  sig { returns(T::Array[T.nilable(Stately::Db::KeyCondition)]) }
  def key_conditions
  end

  # key_conditions are a set of conditions to apply to the list operation.
# Wherever possible, Stately will apply these key conditions at the DB layer
# to optimize the list operation cost.
#
# A maximum of two key conditions are allowed: one with a GREATER_THAN (or equal to)
# operator and one with a LESS_THAN (or equal to) operator. Together these amount to
# a "between" condition on the key path.
#
# If these conditions are provided they must share the same prefix as the
# key_path_prefix. For example, the following is valid:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/namespace-44"
#       operator: GREATER_THAN_OR_EQUAL
#     - key_path: "/group-:groupID/namespace-100"
#       operator: LESS_THAN_OR_EQUAL
#
# A key_path_prefix of "/group-:groupID" would also be valid above, as the prefix is shared
# with the key conditions.
#
# The following is NOT valid because the key_path_prefix does not
# share the same prefix as the key conditions:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/beatles-1984"
#       operator: GREATER_THAN_OR_EQUAL
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def key_conditions=(value)
  end

  # key_conditions are a set of conditions to apply to the list operation.
# Wherever possible, Stately will apply these key conditions at the DB layer
# to optimize the list operation cost.
#
# A maximum of two key conditions are allowed: one with a GREATER_THAN (or equal to)
# operator and one with a LESS_THAN (or equal to) operator. Together these amount to
# a "between" condition on the key path.
#
# If these conditions are provided they must share the same prefix as the
# key_path_prefix. For example, the following is valid:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/namespace-44"
#       operator: GREATER_THAN_OR_EQUAL
#     - key_path: "/group-:groupID/namespace-100"
#       operator: LESS_THAN_OR_EQUAL
#
# A key_path_prefix of "/group-:groupID" would also be valid above, as the prefix is shared
# with the key conditions.
#
# The following is NOT valid because the key_path_prefix does not
# share the same prefix as the key conditions:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/beatles-1984"
#       operator: GREATER_THAN_OR_EQUAL
  sig { void }
  def clear_key_conditions
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::BeginListRequest) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::BeginListRequest).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::BeginListRequest) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::BeginListRequest, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# These are stream messages, so multiple responses may be sent.
class Stately::Db::ListResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      result: T.nilable(Stately::Db::ListPartialResult),
      finished: T.nilable(Stately::Db::ListFinished)
    ).void
  end
  def initialize(
    result: nil,
    finished: nil
  )
  end

  # Result is a segment of the result set - multiple of these may be returned
# in a stream before the final "finished" message.
  sig { returns(T.nilable(Stately::Db::ListPartialResult)) }
  def result
  end

  # Result is a segment of the result set - multiple of these may be returned
# in a stream before the final "finished" message.
  sig { params(value: T.nilable(Stately::Db::ListPartialResult)).void }
  def result=(value)
  end

  # Result is a segment of the result set - multiple of these may be returned
# in a stream before the final "finished" message.
  sig { void }
  def clear_result
  end

  # Finished is sent when there are no more results in this operation, and
# there will only be one.
  sig { returns(T.nilable(Stately::Db::ListFinished)) }
  def finished
  end

  # Finished is sent when there are no more results in this operation, and
# there will only be one.
  sig { params(value: T.nilable(Stately::Db::ListFinished)).void }
  def finished=(value)
  end

  # Finished is sent when there are no more results in this operation, and
# there will only be one.
  sig { void }
  def clear_finished
  end

  sig { returns(T.nilable(Symbol)) }
  def response
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::ListResponse) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::ListResponse).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::ListResponse) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::ListResponse, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::ListPartialResult
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      items: T.nilable(T::Array[T.nilable(Stately::Db::Item)])
    ).void
  end
  def initialize(
    items: []
  )
  end

  # results is a list that contains one entry for each Item that was found.
  sig { returns(T::Array[T.nilable(Stately::Db::Item)]) }
  def items
  end

  # results is a list that contains one entry for each Item that was found.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def items=(value)
  end

  # results is a list that contains one entry for each Item that was found.
  sig { void }
  def clear_items
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::ListPartialResult) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::ListPartialResult).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::ListPartialResult) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::ListPartialResult, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::ListFinished
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      token: T.nilable(Stately::Db::ListToken)
    ).void
  end
  def initialize(
    token: nil
  )
  end

  # token is always set and represents an updated list continuation token that
# can be used in subsequent calls to ContinueList or SyncList.
  sig { returns(T.nilable(Stately::Db::ListToken)) }
  def token
  end

  # token is always set and represents an updated list continuation token that
# can be used in subsequent calls to ContinueList or SyncList.
  sig { params(value: T.nilable(Stately::Db::ListToken)).void }
  def token=(value)
  end

  # token is always set and represents an updated list continuation token that
# can be used in subsequent calls to ContinueList or SyncList.
  sig { void }
  def clear_token
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::ListFinished) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::ListFinished).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::ListFinished) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::ListFinished, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# A KeyCondition is an additional constraint to be applied to the list
# operation. It is used to filter the results based on a specific key path
# and an operator.
# Wherever possible, stately will apply these key conditions at the DB layer
# to optimize the list operation latency and cost.
# Key conditions may be combined with a key_path_prefix to further
# optimize the list operation. HOWEVER Key conditions must share the
# same prefix as the key_path_prefix.
class Stately::Db::KeyCondition
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      key_path: T.nilable(String),
      operator: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    key_path: "",
    operator: :OPERATOR_UNSPECIFIED
  )
  end

  # key_path is a valid key prefix (or full key) used to filter or optimize the list
# operation based on the operator specified below.
  sig { returns(String) }
  def key_path
  end

  # key_path is a valid key prefix (or full key) used to filter or optimize the list
# operation based on the operator specified below.
  sig { params(value: String).void }
  def key_path=(value)
  end

  # key_path is a valid key prefix (or full key) used to filter or optimize the list
# operation based on the operator specified below.
  sig { void }
  def clear_key_path
  end

  # Operator indicates how to apply key_path condition to the list operation.
# Valid options are:
# - GREATER_THAN: key_path must be greater than the specified value
# - GREATER_THAN_OR_EQUAL: key_path must be greater than or equal to the specified value
# - LESS_THAN: key_path must be less than the specified value
# - LESS_THAN_OR_EQUAL: key_path must be less than or equal to the specified value
#
# Note: Operators are strictly evaluated they do not change meaning based on sort direction.
# For example, regardless of sort direction, a GREATER_THAN operator
# will still mean that a key_path must be greater than the specified value in order
# to be included in the result set.
  sig { returns(T.any(Symbol, Integer)) }
  def operator
  end

  # Operator indicates how to apply key_path condition to the list operation.
# Valid options are:
# - GREATER_THAN: key_path must be greater than the specified value
# - GREATER_THAN_OR_EQUAL: key_path must be greater than or equal to the specified value
# - LESS_THAN: key_path must be less than the specified value
# - LESS_THAN_OR_EQUAL: key_path must be less than or equal to the specified value
#
# Note: Operators are strictly evaluated they do not change meaning based on sort direction.
# For example, regardless of sort direction, a GREATER_THAN operator
# will still mean that a key_path must be greater than the specified value in order
# to be included in the result set.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def operator=(value)
  end

  # Operator indicates how to apply key_path condition to the list operation.
# Valid options are:
# - GREATER_THAN: key_path must be greater than the specified value
# - GREATER_THAN_OR_EQUAL: key_path must be greater than or equal to the specified value
# - LESS_THAN: key_path must be less than the specified value
# - LESS_THAN_OR_EQUAL: key_path must be less than or equal to the specified value
#
# Note: Operators are strictly evaluated they do not change meaning based on sort direction.
# For example, regardless of sort direction, a GREATER_THAN operator
# will still mean that a key_path must be greater than the specified value in order
# to be included in the result set.
  sig { void }
  def clear_operator
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::KeyCondition) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::KeyCondition).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::KeyCondition) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::KeyCondition, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

module Stately::Db::SortDirection
  self::SORT_ASCENDING = T.let(0, Integer)
  self::SORT_DESCENDING = T.let(1, Integer)

  sig { params(value: Integer).returns(T.nilable(Symbol)) }
  def self.lookup(value)
  end

  sig { params(value: Symbol).returns(T.nilable(Integer)) }
  def self.resolve(value)
  end

  sig { returns(::Google::Protobuf::EnumDescriptor) }
  def self.descriptor
  end
end

module Stately::Db::Operator
  self::OPERATOR_UNSPECIFIED = T.let(0, Integer)
  self::OPERATOR_GREATER_THAN = T.let(4, Integer)
  self::OPERATOR_GREATER_THAN_OR_EQUAL = T.let(5, Integer)
  self::OPERATOR_LESS_THAN = T.let(6, Integer)
  self::OPERATOR_LESS_THAN_OR_EQUAL = T.let(7, Integer)

  sig { params(value: Integer).returns(T.nilable(Symbol)) }
  def self.lookup(value)
  end

  sig { params(value: Symbol).returns(T.nilable(Integer)) }
  def self.resolve(value)
  end

  sig { returns(::Google::Protobuf::EnumDescriptor) }
  def self.descriptor
  end
end
