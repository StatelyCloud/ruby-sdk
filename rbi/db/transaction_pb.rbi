# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: db/transaction.proto
# typed: strict

# This is a streaming request, so the client may send several of them
class Stately::Db::TransactionRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      message_id: T.nilable(Integer),
      begin: T.nilable(Stately::Db::TransactionBegin),
      get_items: T.nilable(Stately::Db::TransactionGet),
      begin_list: T.nilable(Stately::Db::TransactionBeginList),
      continue_list: T.nilable(Stately::Db::TransactionContinueList),
      put_items: T.nilable(Stately::Db::TransactionPut),
      delete_items: T.nilable(Stately::Db::TransactionDelete),
      commit: T.nilable(Google::Protobuf::Empty),
      abort: T.nilable(Google::Protobuf::Empty)
    ).void
  end
  def initialize(
    message_id: 0,
    begin: nil,
    get_items: nil,
    begin_list: nil,
    continue_list: nil,
    put_items: nil,
    delete_items: nil,
    commit: nil,
    abort: nil
  )
  end

  # message_id should be set to a unique number per request in this
# transaction. It will be returned with responses to make it easier to match
# up specific responses with their requests.
  sig { returns(Integer) }
  def message_id
  end

  # message_id should be set to a unique number per request in this
# transaction. It will be returned with responses to make it easier to match
# up specific responses with their requests.
  sig { params(value: Integer).void }
  def message_id=(value)
  end

  # message_id should be set to a unique number per request in this
# transaction. It will be returned with responses to make it easier to match
# up specific responses with their requests.
  sig { void }
  def clear_message_id
  end

  # begin sets up options for the transaction, such as what store we're
# operating on. It is not acknowledged unless there is an error, which
# kills the whole transaction.
  sig { returns(T.nilable(Stately::Db::TransactionBegin)) }
  def begin
  end

  # begin sets up options for the transaction, such as what store we're
# operating on. It is not acknowledged unless there is an error, which
# kills the whole transaction.
  sig { params(value: T.nilable(Stately::Db::TransactionBegin)).void }
  def begin=(value)
  end

  # begin sets up options for the transaction, such as what store we're
# operating on. It is not acknowledged unless there is an error, which
# kills the whole transaction.
  sig { void }
  def clear_begin
  end

  # The client is requesting to get one or more items. The results will be
# returned in TransactionResponse#get_results.
  sig { returns(T.nilable(Stately::Db::TransactionGet)) }
  def get_items
  end

  # The client is requesting to get one or more items. The results will be
# returned in TransactionResponse#get_results.
  sig { params(value: T.nilable(Stately::Db::TransactionGet)).void }
  def get_items=(value)
  end

  # The client is requesting to get one or more items. The results will be
# returned in TransactionResponse#get_results.
  sig { void }
  def clear_get_items
  end

  # The client is requesting a list of a path prefix. The results will be
# returned in TransactionResponse#list.
  sig { returns(T.nilable(Stately::Db::TransactionBeginList)) }
  def begin_list
  end

  # The client is requesting a list of a path prefix. The results will be
# returned in TransactionResponse#list.
  sig { params(value: T.nilable(Stately::Db::TransactionBeginList)).void }
  def begin_list=(value)
  end

  # The client is requesting a list of a path prefix. The results will be
# returned in TransactionResponse#list.
  sig { void }
  def clear_begin_list
  end

  # ContinueList takes the token from a BeginList call and returns the next
# "page" of results based on the original query parameters and pagination
# options. It has few options because it is a continuation of a previous
# list operation. It will return a new  token which can be used for
# another ContinueList call, and so on. Each time you call either
# ContinueList, you should pass the latest version of the token, and then
# use the new token from the result in subsequent calls. Calls to
# ContinueList are tied to the authorization of the original BeginList
# call, so if the original BeginList call was allowed, ContinueList with
# its token should also be allowed.
  sig { returns(T.nilable(Stately::Db::TransactionContinueList)) }
  def continue_list
  end

  # ContinueList takes the token from a BeginList call and returns the next
# "page" of results based on the original query parameters and pagination
# options. It has few options because it is a continuation of a previous
# list operation. It will return a new  token which can be used for
# another ContinueList call, and so on. Each time you call either
# ContinueList, you should pass the latest version of the token, and then
# use the new token from the result in subsequent calls. Calls to
# ContinueList are tied to the authorization of the original BeginList
# call, so if the original BeginList call was allowed, ContinueList with
# its token should also be allowed.
  sig { params(value: T.nilable(Stately::Db::TransactionContinueList)).void }
  def continue_list=(value)
  end

  # ContinueList takes the token from a BeginList call and returns the next
# "page" of results based on the original query parameters and pagination
# options. It has few options because it is a continuation of a previous
# list operation. It will return a new  token which can be used for
# another ContinueList call, and so on. Each time you call either
# ContinueList, you should pass the latest version of the token, and then
# use the new token from the result in subsequent calls. Calls to
# ContinueList are tied to the authorization of the original BeginList
# call, so if the original BeginList call was allowed, ContinueList with
# its token should also be allowed.
  sig { void }
  def clear_continue_list
  end

  # The client is requesting to create new items. This is acknowledged in
# TransactionResponse#put_ack which contains the item's tentative full path
# (pending the transaction's commit). The final result of all puts will be
# returned in TransactionFinished#put_results.
  sig { returns(T.nilable(Stately::Db::TransactionPut)) }
  def put_items
  end

  # The client is requesting to create new items. This is acknowledged in
# TransactionResponse#put_ack which contains the item's tentative full path
# (pending the transaction's commit). The final result of all puts will be
# returned in TransactionFinished#put_results.
  sig { params(value: T.nilable(Stately::Db::TransactionPut)).void }
  def put_items=(value)
  end

  # The client is requesting to create new items. This is acknowledged in
# TransactionResponse#put_ack which contains the item's tentative full path
# (pending the transaction's commit). The final result of all puts will be
# returned in TransactionFinished#put_results.
  sig { void }
  def clear_put_items
  end

  # The client is requesting to delete items. It is not acknowledged unless
# there is an error, which kills the whole transaction. The final result of
# all deletes will be returned in TransactionFinished#delete_results.
  sig { returns(T.nilable(Stately::Db::TransactionDelete)) }
  def delete_items
  end

  # The client is requesting to delete items. It is not acknowledged unless
# there is an error, which kills the whole transaction. The final result of
# all deletes will be returned in TransactionFinished#delete_results.
  sig { params(value: T.nilable(Stately::Db::TransactionDelete)).void }
  def delete_items=(value)
  end

  # The client is requesting to delete items. It is not acknowledged unless
# there is an error, which kills the whole transaction. The final result of
# all deletes will be returned in TransactionFinished#delete_results.
  sig { void }
  def clear_delete_items
  end

  # The client is requesting to commit the transaction. The final results of
# the transaction will be returned in TransactionResponse#finished.
  sig { returns(T.nilable(Google::Protobuf::Empty)) }
  def commit
  end

  # The client is requesting to commit the transaction. The final results of
# the transaction will be returned in TransactionResponse#finished.
  sig { params(value: T.nilable(Google::Protobuf::Empty)).void }
  def commit=(value)
  end

  # The client is requesting to commit the transaction. The final results of
# the transaction will be returned in TransactionResponse#finished.
  sig { void }
  def clear_commit
  end

  # The client is requesting to abort/rollback the transaction.
  sig { returns(T.nilable(Google::Protobuf::Empty)) }
  def abort
  end

  # The client is requesting to abort/rollback the transaction.
  sig { params(value: T.nilable(Google::Protobuf::Empty)).void }
  def abort=(value)
  end

  # The client is requesting to abort/rollback the transaction.
  sig { void }
  def clear_abort
  end

  sig { returns(T.nilable(Symbol)) }
  def command
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionRequest) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionRequest).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionRequest) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionRequest, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# This is a streaming response, so the server may send several of them
class Stately::Db::TransactionResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      message_id: T.nilable(Integer),
      get_results: T.nilable(Stately::Db::TransactionGetResponse),
      put_ack: T.nilable(Stately::Db::TransactionPutAck),
      list_results: T.nilable(Stately::Db::TransactionListResponse),
      finished: T.nilable(Stately::Db::TransactionFinished)
    ).void
  end
  def initialize(
    message_id: 0,
    get_results: nil,
    put_ack: nil,
    list_results: nil,
    finished: nil
  )
  end

  # message_id is the same as the message_id of the request that triggered this
# response. This makes it easier to distinguish between multiple responses to
# different requests..
  sig { returns(Integer) }
  def message_id
  end

  # message_id is the same as the message_id of the request that triggered this
# response. This makes it easier to distinguish between multiple responses to
# different requests..
  sig { params(value: Integer).void }
  def message_id=(value)
  end

  # message_id is the same as the message_id of the request that triggered this
# response. This makes it easier to distinguish between multiple responses to
# different requests..
  sig { void }
  def clear_message_id
  end

  # The server is responding to a GetItem request
  sig { returns(T.nilable(Stately::Db::TransactionGetResponse)) }
  def get_results
  end

  # The server is responding to a GetItem request
  sig { params(value: T.nilable(Stately::Db::TransactionGetResponse)).void }
  def get_results=(value)
  end

  # The server is responding to a GetItem request
  sig { void }
  def clear_get_results
  end

  # put_ack contains provisionally updated items from a put, including
# tentative IDs (pending transaction commit).
  sig { returns(T.nilable(Stately::Db::TransactionPutAck)) }
  def put_ack
  end

  # put_ack contains provisionally updated items from a put, including
# tentative IDs (pending transaction commit).
  sig { params(value: T.nilable(Stately::Db::TransactionPutAck)).void }
  def put_ack=(value)
  end

  # put_ack contains provisionally updated items from a put, including
# tentative IDs (pending transaction commit).
  sig { void }
  def clear_put_ack
  end

  # list_results is the result of a list request.
  sig { returns(T.nilable(Stately::Db::TransactionListResponse)) }
  def list_results
  end

  # list_results is the result of a list request.
  sig { params(value: T.nilable(Stately::Db::TransactionListResponse)).void }
  def list_results=(value)
  end

  # list_results is the result of a list request.
  sig { void }
  def clear_list_results
  end

  # Final information about the transaction, regardless of whether it was committed or aborted.
  sig { returns(T.nilable(Stately::Db::TransactionFinished)) }
  def finished
  end

  # Final information about the transaction, regardless of whether it was committed or aborted.
  sig { params(value: T.nilable(Stately::Db::TransactionFinished)).void }
  def finished=(value)
  end

  # Final information about the transaction, regardless of whether it was committed or aborted.
  sig { void }
  def clear_finished
  end

  sig { returns(T.nilable(Symbol)) }
  def result
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionResponse) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionResponse).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionResponse) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionResponse, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# TransactionBegin opens a transaction and sets various options that will be
# used throughout the transaction.
class Stately::Db::TransactionBegin
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      store_id: T.nilable(Integer),
      schema_version_id: T.nilable(Integer),
      schema_id: T.nilable(Integer)
    ).void
  end
  def initialize(
    store_id: 0,
    schema_version_id: 0,
    schema_id: 0
  )
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { returns(Integer) }
  def store_id
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { params(value: Integer).void }
  def store_id=(value)
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { void }
  def clear_store_id
  end

  # schema_version_id refers to the item version to base this txn from. All items
# created or modified in this transaction will be based on this schema
# version.
#
# If the store's schema does not have this version, the operation
# will error with SchemaVersionNotFound error. You should not have to
# set this manually as your generated SDK should know its schema version
# and wire this in for you.
  sig { returns(Integer) }
  def schema_version_id
  end

  # schema_version_id refers to the item version to base this txn from. All items
# created or modified in this transaction will be based on this schema
# version.
#
# If the store's schema does not have this version, the operation
# will error with SchemaVersionNotFound error. You should not have to
# set this manually as your generated SDK should know its schema version
# and wire this in for you.
  sig { params(value: Integer).void }
  def schema_version_id=(value)
  end

  # schema_version_id refers to the item version to base this txn from. All items
# created or modified in this transaction will be based on this schema
# version.
#
# If the store's schema does not have this version, the operation
# will error with SchemaVersionNotFound error. You should not have to
# set this manually as your generated SDK should know its schema version
# and wire this in for you.
  sig { void }
  def clear_schema_version_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { returns(Integer) }
  def schema_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { params(value: Integer).void }
  def schema_id=(value)
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { void }
  def clear_schema_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionBegin) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionBegin).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionBegin) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionBegin, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# TransactionGet is a subset of the GetRequest message, for performing point
# gets within the context of a transaction.
class Stately::Db::TransactionGet
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      gets: T.nilable(T::Array[T.nilable(Stately::Db::GetItem)])
    ).void
  end
  def initialize(
    gets: []
  )
  end

  # key paths to of each item to get.
  sig { returns(T::Array[T.nilable(Stately::Db::GetItem)]) }
  def gets
  end

  # key paths to of each item to get.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def gets=(value)
  end

  # key paths to of each item to get.
  sig { void }
  def clear_gets
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionGet) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionGet).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionGet) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionGet, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# TransactionBeginList is a subset of the ListRequest message, for listing within
# the context of a transaction.
class Stately::Db::TransactionBeginList
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      key_path_prefix: T.nilable(String),
      limit: T.nilable(Integer),
      sort_property: T.nilable(T.any(Symbol, String, Integer)),
      sort_direction: T.nilable(T.any(Symbol, String, Integer)),
      filter_conditions: T.nilable(T::Array[T.nilable(Stately::Db::FilterCondition)]),
      key_conditions: T.nilable(T::Array[T.nilable(Stately::Db::KeyCondition)])
    ).void
  end
  def initialize(
    key_path_prefix: "",
    limit: 0,
    sort_property: :SORTABLE_PROPERTY_KEY_PATH,
    sort_direction: :SORT_ASCENDING,
    filter_conditions: [],
    key_conditions: []
  )
  end

  # key_path_prefix is the a prefix that limits what items we will return. This
# must contain at least a root segment. See Item#key_path for more details.
  sig { returns(String) }
  def key_path_prefix
  end

  # key_path_prefix is the a prefix that limits what items we will return. This
# must contain at least a root segment. See Item#key_path for more details.
  sig { params(value: String).void }
  def key_path_prefix=(value)
  end

  # key_path_prefix is the a prefix that limits what items we will return. This
# must contain at least a root segment. See Item#key_path for more details.
  sig { void }
  def clear_key_path_prefix
  end

  # limit is the maximum number of items to return. If this is not specified or
# set to 0, it will be unlimited. Fewer items than the limit may be
# returned even if there are more items to get - make sure to check
# token.can_continue.
  sig { returns(Integer) }
  def limit
  end

  # limit is the maximum number of items to return. If this is not specified or
# set to 0, it will be unlimited. Fewer items than the limit may be
# returned even if there are more items to get - make sure to check
# token.can_continue.
  sig { params(value: Integer).void }
  def limit=(value)
  end

  # limit is the maximum number of items to return. If this is not specified or
# set to 0, it will be unlimited. Fewer items than the limit may be
# returned even if there are more items to get - make sure to check
# token.can_continue.
  sig { void }
  def clear_limit
  end

  # sort_property is the property of the item to sort the results by. If this
# is not set, we will sort by key path.
  sig { returns(T.any(Symbol, Integer)) }
  def sort_property
  end

  # sort_property is the property of the item to sort the results by. If this
# is not set, we will sort by key path.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def sort_property=(value)
  end

  # sort_property is the property of the item to sort the results by. If this
# is not set, we will sort by key path.
  sig { void }
  def clear_sort_property
  end

  # sort_direction is the direction to sort the results in. If this is not set,
# we will sort in ascending order.
  sig { returns(T.any(Symbol, Integer)) }
  def sort_direction
  end

  # sort_direction is the direction to sort the results in. If this is not set,
# we will sort in ascending order.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def sort_direction=(value)
  end

  # sort_direction is the direction to sort the results in. If this is not set,
# we will sort in ascending order.
  sig { void }
  def clear_sort_direction
  end

  # filter_conditions are a set of conditions to filter the list result by.
# If no conditions are provided, all items in the store will be returned.
# Filter conditions are combined with OR.
  sig { returns(T::Array[T.nilable(Stately::Db::FilterCondition)]) }
  def filter_conditions
  end

  # filter_conditions are a set of conditions to filter the list result by.
# If no conditions are provided, all items in the store will be returned.
# Filter conditions are combined with OR.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def filter_conditions=(value)
  end

  # filter_conditions are a set of conditions to filter the list result by.
# If no conditions are provided, all items in the store will be returned.
# Filter conditions are combined with OR.
  sig { void }
  def clear_filter_conditions
  end

  # key_conditions are a set of conditions to apply to the list operation.
# Wherever possible, Stately will apply these key conditions at the DB layer
# to optimize the list operation cost.
#
# A maximum of two key conditions are allowed, one with a GREATER_THAN (or equal to)
# operator and one with a LESS_THAN (or equal to) operator. Together these amount to
# a "between" condition on the key path.
#
# If these conditions are provided they must share the same prefix as the
# key_path_prefix. For example this is valid:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/namespace-44"
#       operator: GREATER_THAN_OR_EQUAL
#     - key_path: "/group-:groupID/namespace-100"
#       operator: LESS_THAN_OR_EQUAL
#
# A key_path_prefix of "/group-:groupID" would also be valid above, as the prefix is shared
# with the key conditions.
#
# The following is NOT valid because the key_path_prefix does not
# share the same prefix as the key conditions:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/beatles-1984"
#       operator: GREATER_THAN_OR_EQUAL
  sig { returns(T::Array[T.nilable(Stately::Db::KeyCondition)]) }
  def key_conditions
  end

  # key_conditions are a set of conditions to apply to the list operation.
# Wherever possible, Stately will apply these key conditions at the DB layer
# to optimize the list operation cost.
#
# A maximum of two key conditions are allowed, one with a GREATER_THAN (or equal to)
# operator and one with a LESS_THAN (or equal to) operator. Together these amount to
# a "between" condition on the key path.
#
# If these conditions are provided they must share the same prefix as the
# key_path_prefix. For example this is valid:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/namespace-44"
#       operator: GREATER_THAN_OR_EQUAL
#     - key_path: "/group-:groupID/namespace-100"
#       operator: LESS_THAN_OR_EQUAL
#
# A key_path_prefix of "/group-:groupID" would also be valid above, as the prefix is shared
# with the key conditions.
#
# The following is NOT valid because the key_path_prefix does not
# share the same prefix as the key conditions:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/beatles-1984"
#       operator: GREATER_THAN_OR_EQUAL
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def key_conditions=(value)
  end

  # key_conditions are a set of conditions to apply to the list operation.
# Wherever possible, Stately will apply these key conditions at the DB layer
# to optimize the list operation cost.
#
# A maximum of two key conditions are allowed, one with a GREATER_THAN (or equal to)
# operator and one with a LESS_THAN (or equal to) operator. Together these amount to
# a "between" condition on the key path.
#
# If these conditions are provided they must share the same prefix as the
# key_path_prefix. For example this is valid:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/namespace-44"
#       operator: GREATER_THAN_OR_EQUAL
#     - key_path: "/group-:groupID/namespace-100"
#       operator: LESS_THAN_OR_EQUAL
#
# A key_path_prefix of "/group-:groupID" would also be valid above, as the prefix is shared
# with the key conditions.
#
# The following is NOT valid because the key_path_prefix does not
# share the same prefix as the key conditions:
#
#   key_path_prefix: "/group-:groupID/namespace"
#   key_conditions:
#     - key_path: "/group-:groupID/beatles-1984"
#       operator: GREATER_THAN_OR_EQUAL
  sig { void }
  def clear_key_conditions
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionBeginList) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionBeginList).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionBeginList) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionBeginList, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::TransactionContinueList
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      token_data: T.nilable(String),
      direction: T.nilable(T.any(Symbol, String, Integer))
    ).void
  end
  def initialize(
    token_data: "",
    direction: :CONTINUE_LIST_FORWARD
  )
  end

  # token is an opaque list continuation token returned by a previous call to
# TransactionBeginList or TransactionContinueList.
  sig { returns(String) }
  def token_data
  end

  # token is an opaque list continuation token returned by a previous call to
# TransactionBeginList or TransactionContinueList.
  sig { params(value: String).void }
  def token_data=(value)
  end

  # token is an opaque list continuation token returned by a previous call to
# TransactionBeginList or TransactionContinueList.
  sig { void }
  def clear_token_data
  end

  # direction indicates whether we are expanding the result set (paginating)
# forward (in the direction of the original List operation) or backward (in
# the opposite direction). The default is to expand forward.
  sig { returns(T.any(Symbol, Integer)) }
  def direction
  end

  # direction indicates whether we are expanding the result set (paginating)
# forward (in the direction of the original List operation) or backward (in
# the opposite direction). The default is to expand forward.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def direction=(value)
  end

  # direction indicates whether we are expanding the result set (paginating)
# forward (in the direction of the original List operation) or backward (in
# the opposite direction). The default is to expand forward.
  sig { void }
  def clear_direction
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionContinueList) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionContinueList).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionContinueList) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionContinueList, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# TransactionPut is a subset of the PutRequest message, for performing puts
# within the context of a transaction. These will not be acknowledged until the
# transaction is finished.
class Stately::Db::TransactionPut
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      puts: T.nilable(T::Array[T.nilable(Stately::Db::PutItem)])
    ).void
  end
  def initialize(
    puts: []
  )
  end

  # items to put into the store.
  sig { returns(T::Array[T.nilable(Stately::Db::PutItem)]) }
  def puts
  end

  # items to put into the store.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def puts=(value)
  end

  # items to put into the store.
  sig { void }
  def clear_puts
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionPut) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionPut).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionPut) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionPut, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# TransactionDelete is a subset of the DeleteRequest message, for performing
# deletes within the context of a transaction. These will not be acknowledged
# until the transaction is finished.
class Stately::Db::TransactionDelete
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      deletes: T.nilable(T::Array[T.nilable(Stately::Db::DeleteItem)])
    ).void
  end
  def initialize(
    deletes: []
  )
  end

  # key paths of items to delete.
  sig { returns(T::Array[T.nilable(Stately::Db::DeleteItem)]) }
  def deletes
  end

  # key paths of items to delete.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def deletes=(value)
  end

  # key paths of items to delete.
  sig { void }
  def clear_deletes
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionDelete) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionDelete).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionDelete) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionDelete, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# TransactionGetResponse is a subset of the GetResponse message, for
# returning results during the execution of a transaction.
class Stately::Db::TransactionGetResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      items: T.nilable(T::Array[T.nilable(Stately::Db::Item)])
    ).void
  end
  def initialize(
    items: []
  )
  end

  # items is a list that contains one entry for each Item that was found.
  sig { returns(T::Array[T.nilable(Stately::Db::Item)]) }
  def items
  end

  # items is a list that contains one entry for each Item that was found.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def items=(value)
  end

  # items is a list that contains one entry for each Item that was found.
  sig { void }
  def clear_items
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionGetResponse) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionGetResponse).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionGetResponse) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionGetResponse, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# GeneratedID represents a unique ID that was generated by the server for a new item.
class Stately::Db::GeneratedID
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      uint: T.nilable(Integer),
      bytes: T.nilable(String)
    ).void
  end
  def initialize(
    uint: 0,
    bytes: ""
  )
  end

  sig { returns(Integer) }
  def uint
  end

  sig { params(value: Integer).void }
  def uint=(value)
  end

  sig { void }
  def clear_uint
  end

  sig { returns(String) }
  def bytes
  end

  sig { params(value: String).void }
  def bytes=(value)
  end

  sig { void }
  def clear_bytes
  end

  sig { returns(T.nilable(Symbol)) }
  def value
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::GeneratedID) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::GeneratedID).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::GeneratedID) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::GeneratedID, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::TransactionPutAck
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      generated_ids: T.nilable(T::Array[T.nilable(Stately::Db::GeneratedID)])
    ).void
  end
  def initialize(
    generated_ids: []
  )
  end

  # generated_ids is a list of generated identifiers for the items in a
# TransactionPut. IDs are returned in the same order of the PutItems provided
# in TransactionPut#puts. For each item where an ID was chosen via its
# "initialValue" property, the chosen value is represented in the returned
# GeneratedID. There is only at most one generated ID per Put, because we
# only allow a single ID property to be generated per item. If the Put didn't
# need any generated IDs, the GeneratedID in its position will be empty.
#
# Clients can use these IDs in subsequent Put operations (e.g. to insert
# child or related items). If the transaction is aborted, the item(s) will
# not be added and other item(s) could be created with the same IDs.
  sig { returns(T::Array[T.nilable(Stately::Db::GeneratedID)]) }
  def generated_ids
  end

  # generated_ids is a list of generated identifiers for the items in a
# TransactionPut. IDs are returned in the same order of the PutItems provided
# in TransactionPut#puts. For each item where an ID was chosen via its
# "initialValue" property, the chosen value is represented in the returned
# GeneratedID. There is only at most one generated ID per Put, because we
# only allow a single ID property to be generated per item. If the Put didn't
# need any generated IDs, the GeneratedID in its position will be empty.
#
# Clients can use these IDs in subsequent Put operations (e.g. to insert
# child or related items). If the transaction is aborted, the item(s) will
# not be added and other item(s) could be created with the same IDs.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def generated_ids=(value)
  end

  # generated_ids is a list of generated identifiers for the items in a
# TransactionPut. IDs are returned in the same order of the PutItems provided
# in TransactionPut#puts. For each item where an ID was chosen via its
# "initialValue" property, the chosen value is represented in the returned
# GeneratedID. There is only at most one generated ID per Put, because we
# only allow a single ID property to be generated per item. If the Put didn't
# need any generated IDs, the GeneratedID in its position will be empty.
#
# Clients can use these IDs in subsequent Put operations (e.g. to insert
# child or related items). If the transaction is aborted, the item(s) will
# not be added and other item(s) could be created with the same IDs.
  sig { void }
  def clear_generated_ids
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionPutAck) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionPutAck).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionPutAck) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionPutAck, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# TransactionListResponse is a subset of the ListResponse message, for
# returning results during the execution of a transaction.
class Stately::Db::TransactionListResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      result: T.nilable(Stately::Db::ListPartialResult),
      finished: T.nilable(Stately::Db::ListFinished)
    ).void
  end
  def initialize(
    result: nil,
    finished: nil
  )
  end

  # Result is a segment of the result set - multiple of these may be returned
# in a stream before the final "finished" message.
  sig { returns(T.nilable(Stately::Db::ListPartialResult)) }
  def result
  end

  # Result is a segment of the result set - multiple of these may be returned
# in a stream before the final "finished" message.
  sig { params(value: T.nilable(Stately::Db::ListPartialResult)).void }
  def result=(value)
  end

  # Result is a segment of the result set - multiple of these may be returned
# in a stream before the final "finished" message.
  sig { void }
  def clear_result
  end

  # Finished is sent when there are no more results in this operation, and
# there will only be one.
  sig { returns(T.nilable(Stately::Db::ListFinished)) }
  def finished
  end

  # Finished is sent when there are no more results in this operation, and
# there will only be one.
  sig { params(value: T.nilable(Stately::Db::ListFinished)).void }
  def finished=(value)
  end

  # Finished is sent when there are no more results in this operation, and
# there will only be one.
  sig { void }
  def clear_finished
  end

  sig { returns(T.nilable(Symbol)) }
  def response
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionListResponse) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionListResponse).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionListResponse) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionListResponse, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::TransactionFinished
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      committed: T.nilable(T::Boolean),
      put_results: T.nilable(T::Array[T.nilable(Stately::Db::Item)]),
      delete_results: T.nilable(T::Array[T.nilable(Stately::Db::DeleteResult)])
    ).void
  end
  def initialize(
    committed: false,
    put_results: [],
    delete_results: []
  )
  end

  # Did the commit finish (the alternative is that it was aborted/rolled back)
  sig { returns(T::Boolean) }
  def committed
  end

  # Did the commit finish (the alternative is that it was aborted/rolled back)
  sig { params(value: T::Boolean).void }
  def committed=(value)
  end

  # Did the commit finish (the alternative is that it was aborted/rolled back)
  sig { void }
  def clear_committed
  end

  # put_results contains the full result of each Put operation. This only comes
# back with the TransactionFinished message because full metadata isn't
# available until then.
  sig { returns(T::Array[T.nilable(Stately::Db::Item)]) }
  def put_results
  end

  # put_results contains the full result of each Put operation. This only comes
# back with the TransactionFinished message because full metadata isn't
# available until then.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def put_results=(value)
  end

  # put_results contains the full result of each Put operation. This only comes
# back with the TransactionFinished message because full metadata isn't
# available until then.
  sig { void }
  def clear_put_results
  end

  # delete_results contains the full result of each Delete operation. This only
# comes back with the TransactionFinished message because full metadata isn't
# available until then.
  sig { returns(T::Array[T.nilable(Stately::Db::DeleteResult)]) }
  def delete_results
  end

  # delete_results contains the full result of each Delete operation. This only
# comes back with the TransactionFinished message because full metadata isn't
# available until then.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def delete_results=(value)
  end

  # delete_results contains the full result of each Delete operation. This only
# comes back with the TransactionFinished message because full metadata isn't
# available until then.
  sig { void }
  def clear_delete_results
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::TransactionFinished) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::TransactionFinished).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::TransactionFinished) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::TransactionFinished, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end
