# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: db/continue_list.proto
# typed: strict

class Stately::Db::ContinueListRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      token_data: T.nilable(String),
      direction: T.nilable(T.any(Symbol, String, Integer)),
      schema_version_id: T.nilable(Integer),
      schema_id: T.nilable(Integer)
    ).void
  end
  def initialize(
    token_data: "",
    direction: :CONTINUE_LIST_FORWARD,
    schema_version_id: 0,
    schema_id: 0
  )
  end

  # token_data is an opaque list continuation token returned by a previous call to
# BeginList, ContinueList, or SyncList.
  sig { returns(String) }
  def token_data
  end

  # token_data is an opaque list continuation token returned by a previous call to
# BeginList, ContinueList, or SyncList.
  sig { params(value: String).void }
  def token_data=(value)
  end

  # token_data is an opaque list continuation token returned by a previous call to
# BeginList, ContinueList, or SyncList.
  sig { void }
  def clear_token_data
  end

  # direction indicates whether we are expanding the result set (paginating)
# forward (in the direction of the original List operation) or backward (in
# the opposite direction). The default is to expand forward.
  sig { returns(T.any(Symbol, Integer)) }
  def direction
  end

  # direction indicates whether we are expanding the result set (paginating)
# forward (in the direction of the original List operation) or backward (in
# the opposite direction). The default is to expand forward.
  sig { params(value: T.any(Symbol, String, Integer)).void }
  def direction=(value)
  end

  # direction indicates whether we are expanding the result set (paginating)
# forward (in the direction of the original List operation) or backward (in
# the opposite direction). The default is to expand forward.
  sig { void }
  def clear_direction
  end

  # schema_version_id is the schema version id the client is using. This is
# used to ensure the same schema version is used across each page of the list.
# If the version the token was created with is different from the client's
# current version, the operation will error with SchemaVersionMismatch error,
# in which case you should start over with a fresh BeginList call.
  sig { returns(Integer) }
  def schema_version_id
  end

  # schema_version_id is the schema version id the client is using. This is
# used to ensure the same schema version is used across each page of the list.
# If the version the token was created with is different from the client's
# current version, the operation will error with SchemaVersionMismatch error,
# in which case you should start over with a fresh BeginList call.
  sig { params(value: Integer).void }
  def schema_version_id=(value)
  end

  # schema_version_id is the schema version id the client is using. This is
# used to ensure the same schema version is used across each page of the list.
# If the version the token was created with is different from the client's
# current version, the operation will error with SchemaVersionMismatch error,
# in which case you should start over with a fresh BeginList call.
  sig { void }
  def clear_schema_version_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { returns(Integer) }
  def schema_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { params(value: Integer).void }
  def schema_id=(value)
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { void }
  def clear_schema_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::ContinueListRequest) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::ContinueListRequest).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::ContinueListRequest) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::ContinueListRequest, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

module Stately::Db::ContinueListDirection
  self::CONTINUE_LIST_FORWARD = T.let(0, Integer)
  self::CONTINUE_LIST_BACKWARD = T.let(1, Integer)

  sig { params(value: Integer).returns(T.nilable(Symbol)) }
  def self.lookup(value)
  end

  sig { params(value: Symbol).returns(T.nilable(Integer)) }
  def self.resolve(value)
  end

  sig { returns(::Google::Protobuf::EnumDescriptor) }
  def self.descriptor
  end
end
