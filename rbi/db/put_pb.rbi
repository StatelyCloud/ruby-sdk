# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: db/put.proto
# typed: strict

class Stately::Db::PutRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      store_id: T.nilable(Integer),
      puts: T.nilable(T::Array[T.nilable(Stately::Db::PutItem)]),
      schema_version_id: T.nilable(Integer)
    ).void
  end
  def initialize(
    store_id: 0,
    puts: [],
    schema_version_id: 0
  )
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { returns(Integer) }
  def store_id
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { params(value: Integer).void }
  def store_id=(value)
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { void }
  def clear_store_id
  end

  # puts is up to 50 items to be put into the Store.
  sig { returns(T::Array[T.nilable(Stately::Db::PutItem)]) }
  def puts
  end

  # puts is up to 50 items to be put into the Store.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def puts=(value)
  end

  # puts is up to 50 items to be put into the Store.
  sig { void }
  def clear_puts
  end

  # schema_version_id refers to the item version to return.
#
# If the store's schema does not have this version, the operation will error
# with SchemaVersionNotFound error. You should not have to set this manually
# as your generated SDK should know its schema version and wire this in for
# you.
  sig { returns(Integer) }
  def schema_version_id
  end

  # schema_version_id refers to the item version to return.
#
# If the store's schema does not have this version, the operation will error
# with SchemaVersionNotFound error. You should not have to set this manually
# as your generated SDK should know its schema version and wire this in for
# you.
  sig { params(value: Integer).void }
  def schema_version_id=(value)
  end

  # schema_version_id refers to the item version to return.
#
# If the store's schema does not have this version, the operation will error
# with SchemaVersionNotFound error. You should not have to set this manually
# as your generated SDK should know its schema version and wire this in for
# you.
  sig { void }
  def clear_schema_version_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::PutRequest) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::PutRequest).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::PutRequest) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::PutRequest, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::PutItem
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      item: T.nilable(Stately::Db::Item),
      overwrite_metadata_timestamps: T.nilable(T::Boolean),
      must_not_exist: T.nilable(T::Boolean)
    ).void
  end
  def initialize(
    item: nil,
    overwrite_metadata_timestamps: false,
    must_not_exist: false
  )
  end

  # item is the data to be put, including its item_type.
  sig { returns(T.nilable(Stately::Db::Item)) }
  def item
  end

  # item is the data to be put, including its item_type.
  sig { params(value: T.nilable(Stately::Db::Item)).void }
  def item=(value)
  end

  # item is the data to be put, including its item_type.
  sig { void }
  def clear_item
  end

  # overwrite_metadata_timestamps indicates that any "fromMetadata" timestamp
# fields in the incoming payload should be saved as provided in the database.
# Normally these would be ignored as they are automatically maintained, but
# this flag can be useful for migrations from other systems. Note that this
# only works for timestamps (createdAtTime and lastModifiedAtTime) - versions
# cannot be overridden.
  sig { returns(T::Boolean) }
  def overwrite_metadata_timestamps
  end

  # overwrite_metadata_timestamps indicates that any "fromMetadata" timestamp
# fields in the incoming payload should be saved as provided in the database.
# Normally these would be ignored as they are automatically maintained, but
# this flag can be useful for migrations from other systems. Note that this
# only works for timestamps (createdAtTime and lastModifiedAtTime) - versions
# cannot be overridden.
  sig { params(value: T::Boolean).void }
  def overwrite_metadata_timestamps=(value)
  end

  # overwrite_metadata_timestamps indicates that any "fromMetadata" timestamp
# fields in the incoming payload should be saved as provided in the database.
# Normally these would be ignored as they are automatically maintained, but
# this flag can be useful for migrations from other systems. Note that this
# only works for timestamps (createdAtTime and lastModifiedAtTime) - versions
# cannot be overridden.
  sig { void }
  def clear_overwrite_metadata_timestamps
  end

  # must_not_exist is a condition that indicates this item must not already
# exist at any of its key paths. If there is already an item at one of those
# paths, the Put operation will fail with a ConditionalCheckFailed error.
# Note that if the item has an `initialValue` field in its key, that initial
# value will automatically be chosen not to conflict with existing items, so
# this condition only applies to key paths that do not contain the
# `initialValue` field.
  sig { returns(T::Boolean) }
  def must_not_exist
  end

  # must_not_exist is a condition that indicates this item must not already
# exist at any of its key paths. If there is already an item at one of those
# paths, the Put operation will fail with a ConditionalCheckFailed error.
# Note that if the item has an `initialValue` field in its key, that initial
# value will automatically be chosen not to conflict with existing items, so
# this condition only applies to key paths that do not contain the
# `initialValue` field.
  sig { params(value: T::Boolean).void }
  def must_not_exist=(value)
  end

  # must_not_exist is a condition that indicates this item must not already
# exist at any of its key paths. If there is already an item at one of those
# paths, the Put operation will fail with a ConditionalCheckFailed error.
# Note that if the item has an `initialValue` field in its key, that initial
# value will automatically be chosen not to conflict with existing items, so
# this condition only applies to key paths that do not contain the
# `initialValue` field.
  sig { void }
  def clear_must_not_exist
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::PutItem) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::PutItem).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::PutItem) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::PutItem, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::PutResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      items: T.nilable(T::Array[T.nilable(Stately::Db::Item)])
    ).void
  end
  def initialize(
    items: []
  )
  end

  # items is the full result of each put operation. The response items are in
# the same order as the request items. Each item is fully "filled out" - for
# example, `initialValue` and `fromMetadata` fields are resolved.
  sig { returns(T::Array[T.nilable(Stately::Db::Item)]) }
  def items
  end

  # items is the full result of each put operation. The response items are in
# the same order as the request items. Each item is fully "filled out" - for
# example, `initialValue` and `fromMetadata` fields are resolved.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def items=(value)
  end

  # items is the full result of each put operation. The response items are in
# the same order as the request items. Each item is fully "filled out" - for
# example, `initialValue` and `fromMetadata` fields are resolved.
  sig { void }
  def clear_items
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::PutResponse) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::PutResponse).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::PutResponse) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::PutResponse, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end
