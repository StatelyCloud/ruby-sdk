# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: db/scan.proto
# typed: strict

class Stately::Db::FilterCondition
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      item_type: T.nilable(String)
    ).void
  end
  def initialize(
    item_type: ""
  )
  end

  # item_type is the type of item to filter by.
  sig { returns(String) }
  def item_type
  end

  # item_type is the type of item to filter by.
  sig { params(value: String).void }
  def item_type=(value)
  end

  # item_type is the type of item to filter by.
  sig { void }
  def clear_item_type
  end

  sig { returns(T.nilable(Symbol)) }
  def value
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::FilterCondition) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::FilterCondition).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::FilterCondition) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::FilterCondition, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::BeginScanRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      store_id: T.nilable(Integer),
      filter_condition: T.nilable(T::Array[T.nilable(Stately::Db::FilterCondition)]),
      limit: T.nilable(Integer),
      segmentation_params: T.nilable(Stately::Db::SegmentationParams),
      schema_version_id: T.nilable(Integer),
      schema_id: T.nilable(Integer)
    ).void
  end
  def initialize(
    store_id: 0,
    filter_condition: [],
    limit: 0,
    segmentation_params: nil,
    schema_version_id: 0,
    schema_id: 0
  )
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { returns(Integer) }
  def store_id
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { params(value: Integer).void }
  def store_id=(value)
  end

  # store_id is a globally unique Store ID, which can be looked up from the
# console or CLI.
  sig { void }
  def clear_store_id
  end

  # filter_condition is a set of conditions to filter the scan result by.
# If no conditions are provided, all items in the store will be returned.
# Filter conditions are combined with OR.
  sig { returns(T::Array[T.nilable(Stately::Db::FilterCondition)]) }
  def filter_condition
  end

  # filter_condition is a set of conditions to filter the scan result by.
# If no conditions are provided, all items in the store will be returned.
# Filter conditions are combined with OR.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def filter_condition=(value)
  end

  # filter_condition is a set of conditions to filter the scan result by.
# If no conditions are provided, all items in the store will be returned.
# Filter conditions are combined with OR.
  sig { void }
  def clear_filter_condition
  end

  # limit is the maximum number of items to return. If this is not specified or
# set to 0, it will return one server side page of items, which may contain zero of your selected
# item types and hence be an empty response.
# Be sure to check token.can_continue to see if you have more items left to fetch.
  sig { returns(Integer) }
  def limit
  end

  # limit is the maximum number of items to return. If this is not specified or
# set to 0, it will return one server side page of items, which may contain zero of your selected
# item types and hence be an empty response.
# Be sure to check token.can_continue to see if you have more items left to fetch.
  sig { params(value: Integer).void }
  def limit=(value)
  end

  # limit is the maximum number of items to return. If this is not specified or
# set to 0, it will return one server side page of items, which may contain zero of your selected
# item types and hence be an empty response.
# Be sure to check token.can_continue to see if you have more items left to fetch.
  sig { void }
  def clear_limit
  end

  # segmentation_params is used to enable parallelization of the list operation.
# This is useful for bulk processing of large stores.
# If this field is set then the list operation will be split into segment_params.total_segments
# and this request will process the segment defined in segmentation_params.segment_index.
# See SegmentationParams for more details.
# Please be warned that parallelization will result on increase throughput to your store
# which may result in throttling.
  sig { returns(T.nilable(Stately::Db::SegmentationParams)) }
  def segmentation_params
  end

  # segmentation_params is used to enable parallelization of the list operation.
# This is useful for bulk processing of large stores.
# If this field is set then the list operation will be split into segment_params.total_segments
# and this request will process the segment defined in segmentation_params.segment_index.
# See SegmentationParams for more details.
# Please be warned that parallelization will result on increase throughput to your store
# which may result in throttling.
  sig { params(value: T.nilable(Stately::Db::SegmentationParams)).void }
  def segmentation_params=(value)
  end

  # segmentation_params is used to enable parallelization of the list operation.
# This is useful for bulk processing of large stores.
# If this field is set then the list operation will be split into segment_params.total_segments
# and this request will process the segment defined in segmentation_params.segment_index.
# See SegmentationParams for more details.
# Please be warned that parallelization will result on increase throughput to your store
# which may result in throttling.
  sig { void }
  def clear_segmentation_params
  end

  # schema_version_id is the version of the store's schema to use to interpret
# items. If there is no version with this ID, the operation will error with
# SchemaVersionNotFound error. You should not have to set this manually as
# your generated SDK should know its schema version and wire this in for you.
  sig { returns(Integer) }
  def schema_version_id
  end

  # schema_version_id is the version of the store's schema to use to interpret
# items. If there is no version with this ID, the operation will error with
# SchemaVersionNotFound error. You should not have to set this manually as
# your generated SDK should know its schema version and wire this in for you.
  sig { params(value: Integer).void }
  def schema_version_id=(value)
  end

  # schema_version_id is the version of the store's schema to use to interpret
# items. If there is no version with this ID, the operation will error with
# SchemaVersionNotFound error. You should not have to set this manually as
# your generated SDK should know its schema version and wire this in for you.
  sig { void }
  def clear_schema_version_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { returns(Integer) }
  def schema_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { params(value: Integer).void }
  def schema_id=(value)
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { void }
  def clear_schema_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::BeginScanRequest) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::BeginScanRequest).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::BeginScanRequest) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::BeginScanRequest, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::SegmentationParams
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      total_segments: T.nilable(Integer),
      segment_index: T.nilable(Integer)
    ).void
  end
  def initialize(
    total_segments: 0,
    segment_index: 0
  )
  end

  # total_segments is used to determine the number of segments the store will be split into.
# The segment_index field will then be used to determine which segment to process.
# For example, if total_segments is set to 5 then the store will be split into 5 segments
# and by setting segment_index to 0, 1, 2, 3, or 4 the request will process the corresponding
# segment.
  sig { returns(Integer) }
  def total_segments
  end

  # total_segments is used to determine the number of segments the store will be split into.
# The segment_index field will then be used to determine which segment to process.
# For example, if total_segments is set to 5 then the store will be split into 5 segments
# and by setting segment_index to 0, 1, 2, 3, or 4 the request will process the corresponding
# segment.
  sig { params(value: Integer).void }
  def total_segments=(value)
  end

  # total_segments is used to determine the number of segments the store will be split into.
# The segment_index field will then be used to determine which segment to process.
# For example, if total_segments is set to 5 then the store will be split into 5 segments
# and by setting segment_index to 0, 1, 2, 3, or 4 the request will process the corresponding
# segment.
  sig { void }
  def clear_total_segments
  end

  # segment_index is used to determine which segment of the store to process
# with this request.
# Segments are zero-indexed so the value of segment_index must be less than total_segments.
  sig { returns(Integer) }
  def segment_index
  end

  # segment_index is used to determine which segment of the store to process
# with this request.
# Segments are zero-indexed so the value of segment_index must be less than total_segments.
  sig { params(value: Integer).void }
  def segment_index=(value)
  end

  # segment_index is used to determine which segment of the store to process
# with this request.
# Segments are zero-indexed so the value of segment_index must be less than total_segments.
  sig { void }
  def clear_segment_index
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::SegmentationParams) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::SegmentationParams).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::SegmentationParams) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::SegmentationParams, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end
