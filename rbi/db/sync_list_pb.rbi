# Code generated by protoc-gen-rbi. DO NOT EDIT.
# source: db/sync_list.proto
# typed: strict

class Stately::Db::SyncListRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      token_data: T.nilable(String),
      schema_version_id: T.nilable(Integer),
      schema_id: T.nilable(Integer)
    ).void
  end
  def initialize(
    token_data: "",
    schema_version_id: 0,
    schema_id: 0
  )
  end

  # token_data is an opaque list continuation token returned by a previous call to
# List, ContinueList, or SyncList.
  sig { returns(String) }
  def token_data
  end

  # token_data is an opaque list continuation token returned by a previous call to
# List, ContinueList, or SyncList.
  sig { params(value: String).void }
  def token_data=(value)
  end

  # token_data is an opaque list continuation token returned by a previous call to
# List, ContinueList, or SyncList.
  sig { void }
  def clear_token_data
  end

  # schema_version_id is the schema version id the client is using. This is
# used to ensure a consistent schema version is used for all items in the result set.
# If the version the token was created with is different from the client's
# current version, the response will contain a SyncListReset response followed by
# items in the client's current schema version. The returned list token can then
# be used for further SyncList and ContinueList calls with the current schema
# version, without having to start a new BeginList call.
  sig { returns(Integer) }
  def schema_version_id
  end

  # schema_version_id is the schema version id the client is using. This is
# used to ensure a consistent schema version is used for all items in the result set.
# If the version the token was created with is different from the client's
# current version, the response will contain a SyncListReset response followed by
# items in the client's current schema version. The returned list token can then
# be used for further SyncList and ContinueList calls with the current schema
# version, without having to start a new BeginList call.
  sig { params(value: Integer).void }
  def schema_version_id=(value)
  end

  # schema_version_id is the schema version id the client is using. This is
# used to ensure a consistent schema version is used for all items in the result set.
# If the version the token was created with is different from the client's
# current version, the response will contain a SyncListReset response followed by
# items in the client's current schema version. The returned list token can then
# be used for further SyncList and ContinueList calls with the current schema
# version, without having to start a new BeginList call.
  sig { void }
  def clear_schema_version_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { returns(Integer) }
  def schema_id
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { params(value: Integer).void }
  def schema_id=(value)
  end

  # schema_id refers to the schema to use for this operation.
# If the store_id does not have a schema with this ID, the operation will
# error with SchemaNotFound error. You should not have to set this manually
# as your generated SDK should know its schema and wire this in for you.
  sig { void }
  def clear_schema_id
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::SyncListRequest) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::SyncListRequest).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::SyncListRequest) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::SyncListRequest, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# These are stream messages, so multiple responses may be sent.
class Stately::Db::SyncListResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      reset: T.nilable(Stately::Db::SyncListReset),
      result: T.nilable(Stately::Db::SyncListPartialResponse),
      finished: T.nilable(Stately::Db::ListFinished)
    ).void
  end
  def initialize(
    reset: nil,
    result: nil,
    finished: nil
  )
  end

  # SyncListReset is returned if the provided token is too far behind to be able to
# report deleted items, or if the client is using a different schema version than
# it started the list with. The following results will start over with a fresh
# result set. Clients should discard any cached data from this result set and start
# re-populating it from the rest of the sync response.
  sig { returns(T.nilable(Stately::Db::SyncListReset)) }
  def reset
  end

  # SyncListReset is returned if the provided token is too far behind to be able to
# report deleted items, or if the client is using a different schema version than
# it started the list with. The following results will start over with a fresh
# result set. Clients should discard any cached data from this result set and start
# re-populating it from the rest of the sync response.
  sig { params(value: T.nilable(Stately::Db::SyncListReset)).void }
  def reset=(value)
  end

  # SyncListReset is returned if the provided token is too far behind to be able to
# report deleted items, or if the client is using a different schema version than
# it started the list with. The following results will start over with a fresh
# result set. Clients should discard any cached data from this result set and start
# re-populating it from the rest of the sync response.
  sig { void }
  def clear_reset
  end

  # Result is a segment of sync results - multiple of these may be returned.
  sig { returns(T.nilable(Stately::Db::SyncListPartialResponse)) }
  def result
  end

  # Result is a segment of sync results - multiple of these may be returned.
  sig { params(value: T.nilable(Stately::Db::SyncListPartialResponse)).void }
  def result=(value)
  end

  # Result is a segment of sync results - multiple of these may be returned.
  sig { void }
  def clear_result
  end

  # Finished is sent when the sync is complete, and there will only be one.
  sig { returns(T.nilable(Stately::Db::ListFinished)) }
  def finished
  end

  # Finished is sent when the sync is complete, and there will only be one.
  sig { params(value: T.nilable(Stately::Db::ListFinished)).void }
  def finished=(value)
  end

  # Finished is sent when the sync is complete, and there will only be one.
  sig { void }
  def clear_finished
  end

  sig { returns(T.nilable(Symbol)) }
  def response
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::SyncListResponse) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::SyncListResponse).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::SyncListResponse) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::SyncListResponse, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

# SyncListReset is returned if the provided token is too far behind to be able to
# report deleted items, and subsequent results will start over with a fresh result
# set. Clients should discard any cached data from this result set and start re-populating it.
class Stately::Db::SyncListReset
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig {void}
  def initialize; end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::SyncListReset) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::SyncListReset).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::SyncListReset) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::SyncListReset, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::SyncListPartialResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      changed_items: T.nilable(T::Array[T.nilable(Stately::Db::Item)]),
      deleted_items: T.nilable(T::Array[T.nilable(Stately::Db::DeletedItem)]),
      updated_item_keys_outside_list_window: T.nilable(T::Array[String])
    ).void
  end
  def initialize(
    changed_items: [],
    deleted_items: [],
    updated_item_keys_outside_list_window: []
  )
  end

  # Items in the token window that were added or updated since the last
# sync/list.
  sig { returns(T::Array[T.nilable(Stately::Db::Item)]) }
  def changed_items
  end

  # Items in the token window that were added or updated since the last
# sync/list.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def changed_items=(value)
  end

  # Items in the token window that were added or updated since the last
# sync/list.
  sig { void }
  def clear_changed_items
  end

  # Items in the token window that were deleted since the last sync/list.
  sig { returns(T::Array[T.nilable(Stately::Db::DeletedItem)]) }
  def deleted_items
  end

  # Items in the token window that were deleted since the last sync/list.
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def deleted_items=(value)
  end

  # Items in the token window that were deleted since the last sync/list.
  sig { void }
  def clear_deleted_items
  end

  # Keys of items that were updated but Stately cannot tell if they were in the
# sync window. Treat these as deleted in most cases. For more information
# see: https://docs.stately.cloud/api/sync
  sig { returns(T::Array[String]) }
  def updated_item_keys_outside_list_window
  end

  # Keys of items that were updated but Stately cannot tell if they were in the
# sync window. Treat these as deleted in most cases. For more information
# see: https://docs.stately.cloud/api/sync
  sig { params(value: ::Google::Protobuf::RepeatedField).void }
  def updated_item_keys_outside_list_window=(value)
  end

  # Keys of items that were updated but Stately cannot tell if they were in the
# sync window. Treat these as deleted in most cases. For more information
# see: https://docs.stately.cloud/api/sync
  sig { void }
  def clear_updated_item_keys_outside_list_window
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::SyncListPartialResponse) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::SyncListPartialResponse).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::SyncListPartialResponse) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::SyncListPartialResponse, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end

class Stately::Db::DeletedItem
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  sig do
    params(
      key_path: T.nilable(String)
    ).void
  end
  def initialize(
    key_path: ""
  )
  end

  # Since the item was deleted, only the key is provided.
  sig { returns(String) }
  def key_path
  end

  # Since the item was deleted, only the key is provided.
  sig { params(value: String).void }
  def key_path=(value)
  end

  # Since the item was deleted, only the key is provided.
  sig { void }
  def clear_key_path
  end

  sig { params(field: String).returns(T.untyped) }
  def [](field)
  end

  sig { params(field: String, value: T.untyped).void }
  def []=(field, value)
  end

  sig { returns(T::Hash[Symbol, T.untyped]) }
  def to_h
  end

  sig { params(str: String).returns(Stately::Db::DeletedItem) }
  def self.decode(str)
  end

  sig { params(msg: Stately::Db::DeletedItem).returns(String) }
  def self.encode(msg)
  end

  sig { params(str: String, kw: T.untyped).returns(Stately::Db::DeletedItem) }
  def self.decode_json(str, **kw)
  end

  sig { params(msg: Stately::Db::DeletedItem, kw: T.untyped).returns(String) }
  def self.encode_json(msg, **kw)
  end

  sig { returns(::Google::Protobuf::Descriptor) }
  def self.descriptor
  end
end
